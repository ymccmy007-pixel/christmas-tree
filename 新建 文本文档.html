<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clear Memories & Neon Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        /* 1. Loader */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffcc00;
            transition: opacity 1s;
        }
        .glow-ring {
            width: 70px; height: 70px; border-radius: 50%;
            border: 4px solid transparent; border-top: 4px solid #ffcc00;
            box-shadow: 0 0 20px #ffcc00; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* 2. UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #header { position: absolute; top: 30px; width: 100%; text-align: center; }
        h1 { 
            margin: 0; color: #fff; letter-spacing: 4px; font-weight: bold; font-size: 24px;
            text-shadow: 0 0 15px #ffcc00;
        }
        #status { color: #ffcc00; font-size: 14px; margin-top: 8px; font-weight: bold; text-transform: uppercase; }

        /* Buttons */
        #upload-btn {
            position: absolute; top: 30px; right: 30px; pointer-events: auto;
            background: rgba(0,0,0,0.7); border: 2px solid #ffcc00; color: #ffcc00;
            padding: 10px 20px; border-radius: 30px; cursor: pointer; font-weight: bold; font-size: 12px;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.3);
        }
        
        /* Camera Feedback */
        .input_video {
            position: absolute; bottom: 30px; left: 30px; width: 150px; 
            border: 2px solid #ffcc00; border-radius: 10px; opacity: 0; 
            transform: scaleX(-1); transition: opacity 0.5s;
        }
        
        /* Gesture Hint */
        #gesture-hint {
            position: absolute; bottom: 40px; width: 100%; text-align: center; color: #aaa; font-size: 12px;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="glow-ring"></div>
        <div>LOADING EXPERIENCE...</div>
    </div>

    <div id="ui-layer">
        <div id="header">
            <h1>NEON MEMORIES</h1>
            <div id="status">Interactive Light Show</div>
        </div>
        <label id="upload-btn">
            + Upload Photos
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
        <div id="gesture-hint">üñê Open Hand: Scatter &nbsp;|&nbsp; üëå Pinch: Grab Photo</div>
    </div>

    <video class="input_video" playsinline muted autoplay></video>

    <script>
        // === Loader Logic ===
        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = url; s.crossOrigin = "anonymous";
                s.onload = resolve; s.onerror = reject;
                document.head.appendChild(s);
            });
        }

        async function init() {
            try {
                await loadScript("https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js");
                const b = "https://unpkg.com/three@0.128.0/examples/js";
                await loadScript(`${b}/shaders/CopyShader.js`);
                await loadScript(`${b}/shaders/LuminosityHighPassShader.js`);
                await loadScript(`${b}/postprocessing/EffectComposer.js`);
                await loadScript(`${b}/postprocessing/ShaderPass.js`);
                await loadScript(`${b}/postprocessing/RenderPass.js`);
                await loadScript(`${b}/postprocessing/UnrealBloomPass.js`);
                const m = "https://cdn.jsdelivr.net/npm/@mediapipe";
                await loadScript(`${m}/camera_utils/camera_utils.js`);
                await loadScript(`${m}/control_utils/control_utils.js`);
                await loadScript(`${m}/drawing_utils/drawing_utils.js`);
                await loadScript(`${m}/hands/hands.js`);

                start3D();
                startAI();

                setTimeout(() => {
                    const l = document.getElementById('loader');
                    l.style.opacity = 0; setTimeout(()=>l.remove(), 1000);
                }, 800);
            } catch(e) { alert("Error: " + e); }
        }

        // === 3D Engine ===
        let scene, camera, renderer, composer;
        let mainGroup, sparkleGroup;
        let objects = [], sparkles = [], photoTextures = [];
        let currentState = 'TREE';
        let activePhotoIndex = -1;
        let handRot = { x:0, y:0 }, isHandActive = false;
        let time = 0;

        function start3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000802, 0.02); // Dark Green Fog

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 55);
            camera.lookAt(0, 8, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            document.body.appendChild(renderer.domElement);

            // === Bloom (Adjusted for Clear Photos) ===
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            // ÂÖ≥ÈîÆ‰øÆÊîπÔºöÊèêÈ´òÈòàÂÄºÔºåÂè™ÊúâÈùûÂ∏∏‰∫ÆÁöÑ‰∏úË•ø(Ê†ë)ÊâçÂèëÂÖâÔºåÁÖßÁâá‰∏çÂèëÂÖâ
            bloomPass.threshold = 0.2; 
            bloomPass.strength = 1.8; // Ê†ë‰æùÁÑ∂Âæà‰∫Æ
            bloomPass.radius = 0.6;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lights
            scene.add(new THREE.AmbientLight(0x222222)); // Base light for photos
            
            const coreLight = new THREE.PointLight(0xffaa00, 2, 50);
            coreLight.position.set(0, 10, 0);
            scene.add(coreLight);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            sparkleGroup = new THREE.Group();
            scene.add(sparkleGroup);
            createBackgroundSparkles();

            generateLuminousTree();

            // Inputs
            window.addEventListener('resize', onResize);
            document.getElementById('file-input').addEventListener('change', handleUpload);
            document.addEventListener('mousedown', () => { if(!isHandActive) setState('SCATTER', '‚ú® SCATTER MODE'); });
            document.addEventListener('mouseup', () => { if(!isHandActive) setState('TREE', 'üéÑ TREE MODE'); });
            document.addEventListener('mousemove', (e) => {
                if(!isHandActive) {
                    handRot.x = (e.clientX/window.innerWidth)*2-1;
                    handRot.y = -(e.clientY/window.innerHeight)*2+1;
                }
            });

            animate();
        }

        function createBackgroundSparkles() {
            const geo = new THREE.SphereGeometry(0.1, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            for(let i=0; i<400; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random()-0.5)*200, (Math.random()-0.5)*150, (Math.random()-0.5)*100 - 30);
                mesh.userData = { speed: Math.random()*0.05, offset: Math.random()*100 };
                sparkleGroup.add(mesh);
                sparkles.push(mesh);
            }
        }

        // Custom Geometries
        function createBrightHat() {
            const group = new THREE.Group();
            const coneMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0033, emissive: 0xff0000, emissiveIntensity: 0.6,
                roughness: 0.3
            });
            const cone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.0, 16), coneMat);
            cone.position.y = 0.5;
            
            const whiteMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, emissive: 0xaaaaaa, emissiveIntensity: 0.4
            });
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.15, 8, 16), whiteMat);
            ring.rotation.x = Math.PI/2;
            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), whiteMat);
            ball.position.y = 1.0;

            group.add(cone, ring, ball);
            group.rotation.z = (Math.random()-0.5)*0.5;
            return group;
        }

        function createGlowingStar(size, color=0xffdd00) {
            const shape = new THREE.Shape();
            const points = 5;
            for (let i=0; i<points*2; i++) {
                const l = i%2===1 ? size : size/2;
                const a = i/points * Math.PI;
                shape.lineTo(Math.cos(a)*l, Math.sin(a)*l);
            }
            const geo = new THREE.ExtrudeGeometry(shape, { depth: size/5, bevelEnabled:false });
            geo.center();
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, emissive: color, emissiveIntensity: 1.2, // Strong Glow
                metalness: 0.9, roughness: 0.0
            });
            return new THREE.Mesh(geo, mat);
        }

        function generateLuminousTree() {
            mainGroup.clear();
            objects = [];

            // Top Star
            const topStar = createGlowingStar(2.5, 0xffcc00);
            const topPos = new THREE.Vector3(0, 18, 0);
            topStar.position.copy(topPos);
            mainGroup.add(topStar);
            objects.push({
                mesh: topStar, posTree: topPos, posScatter: new THREE.Vector3(0,0,0),
                isPhoto: false, isTopStar: true, phase: 0
            });

            const geoDiamond = new THREE.IcosahedronGeometry(0.6, 0);
            const geoGem = new THREE.OctahedronGeometry(0.5, 0);
            const geoCard = new THREE.PlaneGeometry(3.5, 4.5); // Photo Card

            // Neon Materials (Tree)
            const matGold = new THREE.MeshStandardMaterial({ 
                color: 0xffcc00, metalness: 0.9, roughness: 0.0,
                emissive: 0xffaa00, emissiveIntensity: 0.8
            });
            const matEmerald = new THREE.MeshStandardMaterial({ 
                color: 0x00ff66, metalness: 0.8, roughness: 0.1,
                emissive: 0x00aa44, emissiveIntensity: 0.8
            });

            const count = 550;

            for(let i=0; i<count; i++) {
                let mesh, isPhoto=false;
                const rand = Math.random();

                // 20% Photos
                if(rand > 0.8 && photoTextures.length > 0) {
                    // ÂÖ≥ÈîÆ‰øÆÊ≠£Ôºö‰ΩøÁî® Basic ÊùêË¥®‰∏îÂÖ≥Èó≠ ToneMappingÔºå‰øùËØÅÁÖßÁâáÊ∏ÖÊô∞„ÄÅËâ≤ÂΩ©ËøòÂéü
                    const mat = new THREE.MeshBasicMaterial({ 
                        map: photoTextures[i%photoTextures.length], 
                        side: THREE.DoubleSide,
                        toneMapped: false // Èò≤Ê≠¢ÁÖßÁâáÈ¢úËâ≤Ë¢´Ê¥óÁôΩ
                    });
                    mesh = new THREE.Mesh(geoCard, mat);
                    isPhoto = true;
                }
                else if(rand > 0.7) mesh = createBrightHat();
                else if(rand > 0.55) mesh = createGlowingStar(0.4, 0xffdd88);
                else if(rand > 0.3) mesh = new THREE.Mesh(geoDiamond, matGold.clone());
                else mesh = new THREE.Mesh(geoGem, matEmerald.clone());

                // Positions
                const y = Math.random() * 32;
                const r = (1 - y/32) * 13;
                const a = y * 9 + Math.random() * 6.28;
                const posTree = new THREE.Vector3(Math.cos(a)*r, y-14, Math.sin(a)*r);

                const rS = 35 + Math.random()*25;
                const theta = Math.random()*6.28;
                const phi = Math.random()*3.14;
                const posScatter = new THREE.Vector3(
                    rS * Math.sin(phi) * Math.cos(theta),
                    rS * Math.sin(phi) * Math.sin(theta),
                    rS * Math.cos(phi)
                );

                mesh.position.copy(posTree);
                mesh.rotation.set(Math.random()*6, Math.random()*6, 0);

                mainGroup.add(mesh);
                objects.push({ 
                    mesh, posTree, posScatter, isPhoto, isTopStar: false,
                    phase: Math.random() * Math.PI * 2,
                    baseScale: mesh.scale.x
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            if(currentState === 'SCATTER') {
                mainGroup.rotation.y += (handRot.x * 2.5 - mainGroup.rotation.y) * 0.05;
                mainGroup.rotation.x += (handRot.y * 1.5 - mainGroup.rotation.x) * 0.05;
            } else {
                mainGroup.rotation.y += 0.005;
                mainGroup.rotation.x *= 0.95;
            }

            sparkles.forEach(s => { s.position.y += Math.sin(time + s.userData.offset)*0.05; });
            sparkleGroup.rotation.y -= 0.002;

            objects.forEach((obj, idx) => {
                let target = currentState === 'SCATTER' ? obj.posScatter : obj.posTree;

                // Zoom Logic
                if(currentState === 'ZOOM' && idx === activePhotoIndex) {
                    target = camera.position.clone().sub(new THREE.Vector3(0,0,12));
                    obj.mesh.lookAt(camera.position);
                    // ÊîæÂ§ßÁÖßÁâá
                    obj.mesh.scale.setScalar(obj.isTopStar ? 3 : 2.0); 
                } else {
                    if(obj.mesh.scale.x > 1.2) obj.mesh.scale.setScalar(obj.baseScale || 1);
                    if(currentState === 'ZOOM') target = obj.posScatter.clone().multiplyScalar(1.2);
                    if(currentState === 'SCATTER') {
                        target = target.clone();
                        target.y += Math.sin(time + idx*0.1) * 0.6;
                    }
                }

                obj.mesh.position.lerp(target, 0.06);

                if(!obj.isPhoto) {
                    obj.mesh.rotation.y += 0.02; 
                    if(obj.mesh.material && obj.mesh.material.emissive) {
                        const pulse = 1.0 + Math.sin(time * 4 + obj.phase) * 0.4;
                        obj.mesh.material.emissiveIntensity = pulse;
                    }
                    if(obj.isTopStar) {
                        obj.mesh.rotation.y += 0.03;
                        obj.mesh.rotation.z = Math.sin(time*2) * 0.1;
                    }
                }
            });

            composer.render();
        }

        // === AI Gesture Logic (Relaxed Pinch) ===
        async function startAI() {
            if(!window.Hands) return;
            const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7});
            
            hands.onResults(results => {
                const vid = document.querySelector('.input_video');
                if(results.multiHandLandmarks.length > 0) {
                    if(!isHandActive) { isHandActive = true; vid.style.opacity = 1; }
                    
                    const lm = results.multiHandLandmarks[0];
                    handRot.x = (0.5 - lm[9].x) * 3;
                    handRot.y = (0.5 - lm[9].y) * 2;

                    // ÂÆΩÊùæÁöÑÊçèÂêàÊ£ÄÊµã (Relaxed threshold from 0.05 to 0.08)
                    const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    const open = lm[8].y < lm[6].y;

                    // ÈÄªËæëÔºöÂè™Ë¶ÅÊòØÊï£ÂºÄÁä∂ÊÄÅÔºå‰∏ÄÊçèÂêàÂ∞±ÊäìÁÖßÁâá
                    if(pinch < 0.08 && currentState === 'SCATTER') {
                        const photos = objects.map((o,i)=>({...o,i})).filter(o=>o.isPhoto);
                        if(photos.length>0) {
                            // ÈöèÊú∫ÊäìÂèñ‰∏ÄÂº†
                            if(activePhotoIndex === -1) {
                                activePhotoIndex = photos[Math.floor(Math.random()*photos.length)].i;
                                setState('ZOOM', 'üì∏ VIEWING PHOTO');
                            }
                        } else {
                            // Ê≤°ÊúâÁÖßÁâáÊó∂ÊèêÁ§∫
                            setState('SCATTER', '‚ö† NO PHOTOS UPLOADED');
                        }
                    } else if(pinch > 0.1 && currentState === 'ZOOM') {
                        // ÊùæÂºÄÊâãÂõûÂà∞Êï£ÂºÄ
                        activePhotoIndex = -1;
                        setState('SCATTER', '‚ú® GALAXY MODE');
                    } else if(open) {
                        if(currentState !== 'SCATTER' && currentState !== 'ZOOM') setState('SCATTER', '‚ú® GALAXY MODE');
                    } else if(!open && pinch > 0.1) {
                        // Êè°Êã≥‰∏îÊ≤°ÊçèÂêà
                        if(currentState !== 'TREE') {
                            setState('TREE', 'üéÑ TREE MODE');
                            activePhotoIndex = -1;
                        }
                    }
                } else {
                    if(isHandActive) { isHandActive = false; vid.style.opacity = 0; }
                }
            });

            const vid = document.querySelector('.input_video');
            const cam = new Camera(vid, {onFrame: async()=>{ await hands.send({image: vid}) }, width: 320, height: 240});
            await cam.start();
        }

        function setState(s, t) { currentState = s; document.getElementById('status').innerText = t; }
        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }
        function handleUpload(e) {
            const files = e.target.files;
            photoTextures = [];
            for(let f of files) {
                const r = new FileReader();
                r.onload = ev => {
                    const i = new Image(); i.src = ev.target.result;
                    const t = new THREE.Texture(i); i.onload=()=>t.needsUpdate=true;
                    photoTextures.push(t);
                    if(photoTextures.length === files.length) {
                        generateLuminousTree();
                        alert("Photos Ready! Pinch to Zoom.");
                    }
                };
                r.readAsDataURL(f);
            }
        }

        init();
    </script>
</body>
</html>
